#!/usr/bin/python
#
# git-deps - automatically detect dependencies between git commits
# Copyright (C) 2013 Adam Spiers <git@adamspiers.org>
#
# The software in this repository is free software: you can redistribute
# it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import argparse
import logging
import os
import re
import sys
import subprocess
import types
from textwrap import dedent, wrap

import pygit2

def abort(msg, exitcode=1):
    print(msg, file=sys.stderr)
    sys.exit(exitcode)

class DependencyListener(object):
    """Class for listening to result events generated by
    DependencyDetector.  Add an instance of this class to a
    DependencyDetector instance via DependencyDetector.add_listener().
    """

    def __init__(self, options):
        self.options = options

    def new_dependent(self, dependent):
        pass

    def new_dependency(self, dependent, dependency, path, line_num):
        pass

    def new_path(self, dependent, dependency, path, line_num):
        pass

    def new_line(self, dependent, dependency, path, line_num):
        pass

    def dependent_done(self, dependent, dependencies):
        pass

class CLIDependencyListener(DependencyListener):
    """Dependency listener for use when running in CLI mode.

    This allows us to output dependencies as they are discovered,
    rather than waiting for all dependencies to be discovered before
    outputting anything; the latter approach can make the user wait
    too long for useful output if recursion is enabled.
    """

    def new_dependency(self, dependent, dependency, path, line_num):
        dependent_sha  = dependent.hex
        dependency_sha = dependency.hex

        if self.options.recurse:
            if self.options.log:
                print("%s depends on:" % dependent_sha)
            else:
                print("%s %s" % (dependent_sha, dependency_sha))
        else:
            if not self.options.log:
                print(dependency_sha)

        if self.options.log:
            cmd = [ 'git', '--no-pager', '-c', 'color.ui=always', 'log', '-n1', dependency_sha ]
            print(subprocess.check_output(cmd))
            # dependency = detector.get_commit(dependency_sha)
            # print(dependency.message + "\n")

        # for path in self.dependencies[dependency]:
        #     print("  %s" % path)
        #     print("    %s" % ", ".join(sorted(self.dependencies[dependency][path].keys())))

class DependencyDetector(object):
    """Class for automatically detecting dependencies between git commits.
    A dependency is inferred by diffing the commit with each of its
    parents, and for each resulting hunk, performing a blame to see
    which commit was responsible for introducing the lines to which
    the hunk was applied.

    Dependencies can be traversed recursively, building a dependency
    tree represented (conceptually) by a list of edges.
    """

    def __init__(self, options, repo_path=None, logger=None, listener=None):
        self.options = options

        if logger is None:
            self.logger = self.default_logger()

        if repo_path is None:
            try:
                repo_path = pygit2.discover_repository('.')
            except KeyError:
                abort("Couldn't find a repository in the current directory.")

        self.repo = pygit2.Repository(repo_path)

        # Nested dict mapping dependents -> dependencies -> files
        # causing that dependency -> numbers of lines within that file
        # causing that dependency.  The first two levels form edges in
        # the dependency graph, and the latter two tell us what caused
        # those edges.
        self.dependencies = {}

        # A TODO list (queue) and dict of dependencies which haven't
        # yet been recursively followed.  Only useful when recursing.
        self.todo   = []
        self.todo_d = {}

        # An ordered list and dict of commits whose dependencies we
        # have already detected.
        self.done   = []
        self.done_d = {}

        # A cache mapping SHAs to commit objects
        self.commits = {}

        # Memoization for branch_contains()
        self.branch_contains_cache = {}

        # Callbacks to be invoked when a new dependency has been
        # discovered.
        self.listeners = []

        if listener:
            self.listeners.append(listener)

    def add_listener(self, listener):
        if not isinstance(listener, types.Functiontype):
            raise RuntimeError("listener must be a function")
        self.listener.append(listener)

    def notify_listeners(self, event, *args):
        for listener in self.listeners:
            fn = getattr(listener, event)
            fn(*args)

    def default_logger(self):
        if not self.options.debug:
            return logging.getLogger(self.__class__.__name__)

        log_format = '%(asctime)-15s %(levelname)-6s %(message)s'
        date_format = '%b %d %H:%M:%S'
        formatter = logging.Formatter(fmt=log_format, datefmt=date_format)
        handler = logging.StreamHandler(stream=sys.stdout)
        handler.setFormatter(formatter)
        #logger = logging.getLogger(__name__)
        logger = logging.getLogger(self.__class__.__name__)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)
        return logger

    def get_commit(self, rev):
        if rev in self.commits:
            return self.commits[rev]

        try:
            self.commits[rev] = self.repo.revparse_single(rev)
        except KeyError:
            abort("Couldn't parse %s" % rev)

        return self.commits[rev]

    def find_dependencies(self, dependent_rev, recurse=None):
        if recurse is None:
            recurse = self.options.recurse

        dependent = self.get_commit(dependent_rev)
        self.todo.append(dependent)
        self.todo_d[dependent.hex] = True

        while self.todo:
            self.logger.debug("TODO list: %s" %
                              " ".join([ commit.hex[:8] for commit in self.todo ]))
            dependent = self.todo.pop(0)
            del self.todo_d[dependent.hex]
            self.logger.debug("Processing %s from TODO list" % dependent.hex[:8])

            for parent in dependent.parents:
                self.find_dependencies_with_parent(dependent, parent)
            self.done.append(dependent.hex)
            self.done_d[dependent.hex] = True
            self.logger.debug("Found all dependencies for %s" % dependent.hex[:8])
            # A commit won't have any dependencies if it only added new files
            dependencies = self.dependencies.get(dependent.hex, {})
            self.notify_listeners('dependent_done', dependent, dependencies)

    def find_dependencies_with_parent(self, dependent, parent):
        self.logger.debug("  Finding dependencies of %s via parent %s" %
                          (dependent.hex[:8], parent.hex[:8]))
        diff = self.repo.diff(parent, dependent, context_lines=self.options.context_lines)
        for patch in diff:
            path = patch.old_file_path
            self.logger.debug("    Examining hunks in %s" % path)
            for hunk in patch.hunks:
                self.blame_hunk(dependent, parent, path, hunk)

    def blame_hunk(self, dependent, parent, path, hunk):
        first_line_num = hunk.old_start
        line_range_before = "-%d,%d" % (hunk.old_start, hunk.old_lines)
        line_range_after  = "+%d,%d" % (hunk.new_start, hunk.new_lines)
        self.logger.debug("      Blaming hunk %s @ %s" %
                          (line_range_before, parent.hex[:8]))

        if not self.tree_lookup(path, parent):
            # This is probably because dependent added a new directory
            # which was not previously in the parent.
            return

        cmd = [
            'git', 'blame',
            '--porcelain',
            '-L', "%d,+%d" % (hunk.old_start, hunk.old_lines),
            parent.hex, '--', path
        ]
        blame = subprocess.check_output(cmd)

        dependent_sha = dependent.hex
        if dependent_sha not in self.dependencies:
            self.logger.debug('        New dependent: %s (%s)' %
                              (dependent_sha[:8], self.oneline(dependent)))
            self.dependencies[dependent_sha] = {}
            self.notify_listeners('new_dependent', dependent)

        line_to_culprit = {}

        for line in blame.split('\n'):
            #self.logger.debug('      !' + line.rstrip())
            m = re.match('^([0-9a-f]{40}) (\d+) (\d+)( \d+)?$', line)
            if not m:
                continue
            dependency_sha, orig_line_num, line_num = m.group(1, 2, 3)
            line_num = int(line_num)
            dependency = self.get_commit(dependency_sha)
            line_to_culprit[line_num] = dependency.hex

            if self.is_excluded(dependency):
                self.logger.debug('        Excluding dependency %s from line %s (%s)' %
                                  (dependency_sha[:8], line_num,
                                   self.oneline(dependency)))
                continue

            if dependency_sha not in self.dependencies[dependent_sha]:
                if dependency_sha in self.todo_d:
                    self.logger.debug('        Dependency %s via line %s already in TODO' %
                                      (dependency_sha[:8], line_num,))
                    continue

                if dependency_sha in self.done_d:
                    self.logger.debug('        Dependency %s via line %s already done' %
                                      (dependency_sha[:8], line_num,))
                    continue

                self.logger.debug('        New dependency %s via line %s (%s)' %
                                  (dependency_sha[:8], line_num,
                                   self.oneline(dependency)))
                self.dependencies[dependent_sha][dependency_sha] = {}
                self.notify_listeners('new_dependency', dependent, dependency, path, line_num)
                if dependency_sha not in self.dependencies:
                    if self.options.recurse:
                        self.todo.append(dependency)
                        self.todo_d[dependency.hex] = True
                        self.logger.debug('          added to TODO')

            if path not in self.dependencies[dependent_sha][dependency_sha]:
                self.dependencies[dependent_sha][dependency_sha][path] = {}
                self.notify_listeners('new_path', dependent, dependency, path, line_num)

            if line_num in self.dependencies[dependent_sha][dependency_sha][path]:
                abort("line %d already found when blaming %s:%s" %
                      (line_num, parent.hex[:8], path))

            self.dependencies[dependent_sha][dependency_sha][path][line_num] = True
            self.notify_listeners('new_line', dependent, dependency, path, line_num)

        diff_format = '      |%8.8s %5s %s%s'
        hunk_header = '@@ %s %s @@' % (line_range_before, line_range_after)
        self.logger.debug(diff_format % ('--------', '-----', '', hunk_header))
        line_num = hunk.old_start
        for mode, line in hunk.lines:
            if mode == '+':
                rev = ln = ''
            else:
                rev = line_to_culprit[line_num]
                ln = line_num
                line_num += 1
            self.logger.debug(diff_format % (rev, ln, mode, line.rstrip()))

    def oneline(self, commit):
        return commit.message.split('\n', 1)[0]

    def is_excluded(self, commit):
        for exclude in self.options.exclude_commits:
            if self.branch_contains(commit, exclude):
                return True
        return False

    def branch_contains(self, commit, branch):
        self.logger.debug("        Does %s contain %s?" % (branch, commit.hex[:8]))
        branch_commit = self.get_commit(branch)

        if commit.hex not in self.branch_contains_cache:
            self.branch_contains_cache[commit.hex] = {}
        if branch_commit.hex in self.branch_contains_cache[commit.hex]:
            memoized = self.branch_contains_cache[commit.hex][branch_commit.hex]
            self.logger.debug("          %s (memoized)" % memoized)
            return memoized

        cmd = [ 'git', 'merge-base', commit.hex, branch_commit.hex ]
        #self.logger.debug(" ".join(cmd))
        out = subprocess.check_output(cmd).strip()
        #self.logger.debug(out)
        result = out == commit.hex
        self.logger.debug("          %s" % result)
        self.branch_contains_cache[commit.hex][branch_commit.hex] = result
        return result

    def tree_lookup(self, target_path, commit):
        """Navigate to the tree or blob object pointed to by the given target
        path for the given commit.  This is necessary because each git
        tree only contains entries for the directory it refers to, not
        recursively for all subdirectories.
        """
        segments = target_path.split("/")
        tree_or_blob = commit.tree
        path = ''
        while segments:
            dirent = segments.pop(0)
            if isinstance(tree_or_blob, pygit2.Tree):
                if dirent in tree_or_blob:
                    tree_or_blob = self.repo[tree_or_blob[dirent].oid]
                    #self.logger.debug('%s in %s' % (dirent, path))
                    if path:
                        path += '/'
                    path += dirent
                else:
                    # This is probably because we were called on a
                    # commit whose parent added a new directory.
                    self.logger.debug('      %s not in %s in %s' %
                                      (dirent, path, commit.hex[:8]))
                    return None
            else:
                self.logger.debug('      %s not a tree in %s' %
                                  (tree_or_blob, commit.hex[:8]))
                return None
        return tree_or_blob

    def edges(self):
        return [
            [ (dependent, dependency) for dependency in self.dependencies[dependent] ]
            for dependent in self.dependencies.keys()
        ]

def parse_args():
    parser = argparse.ArgumentParser(
        description='Auto-detects commits which the given commit(s) depend on.',
        usage='%(prog)s [options] COMMIT-ISH [COMMIT-ISH...]'
    )
    parser.add_argument('-l', '--log', dest='log', action='store_true',
                        help='Show commit logs for calculated dependencies [%(default)s]')
    parser.add_argument('-r', '--recurse', dest='recurse', action='store_true',
                        help='Follow dependencies recursively [%(default)s]')
    parser.add_argument('-e', '--exclude-commits', dest='exclude_commits',
                        action='append', metavar='COMMITISH',
                        help='Exclude commits which are ancestors of the given COMMITISH'
                        ' (can be repeated)')
    parser.add_argument('-c', '--context-lines', dest='context_lines', type=int,
                        metavar='NUM', default=1,
                        help='Number of lines of diff context to use [%(default)s]')
    parser.add_argument('-d', '--debug', dest='debug', action='store_true',
                        help='Show debugging [%(default)s]')

    options, args = parser.parse_known_args()

    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    return options, args

def main():
    options, args = parse_args()
    #rev_list = sys.stdin.readlines()
    listener = CLIDependencyListener(options)
    detector = DependencyDetector(options, listener=listener)

    for dependent_rev in args:
        try:
            detector.find_dependencies(dependent_rev)
        except KeyboardInterrupt:
            pass

if __name__ == "__main__":
    main()
